local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()
local window = DrRayLibrary:Load("Faith.pub", "Default")

local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local UIS = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- // 1. PROPER SETTINGS TABLE //
local settings = {
    silentAim = {
        Enabled = false,
        HitPart = "Head",
        MaxDistance = 2500,
        TargetSleeping = true,
        TargetScientists = false,
        Fov = { 
            Visible = false, 
            BaseRadius = 200, 
            Color = Color3.fromRGB(255, 255, 255), 
            Thickness = 1, 
            Transparency = 1, 
            Filled = false -- ALWAYS FALSE PER INSTRUCTION
        },
        Snapline = { Enabled = true, Color = Color3.fromRGB(255, 255, 255) },
        Highlight = { Enabled = true, Color = Color3.fromRGB(255, 255, 255), FillTransparency = 1 }
    },
    esp = {
        Enabled = true,
        Box = true,
        Skeleton = true,
        Name = true,
        Weapon = true,
        Armor = true,
        Distance = true,
        SleepCheck = true,
        NoBot = false, -- BOT CHECK OFF PER INSTRUCTION
        ShowCorpses = true
    },
    combat = {
        HitboxEnabled = true,
        HitPart = "Head", -- PICK FROM TORSO AND HEAD
        HitboxSize = 8.4
    },
    misc = {
        FreecamEnabled = false,
        JumpShoot = true,
        HitIndicatorEnabled = false
    }
}

-- // 2. DATA SCRAPING & HOOKING //
local players_data = {}
local createProjectile
for i, v in getgc() do
    if typeof(v) == "function" and not iscclosure(v) then
        local consts = debug.getconstants(v)
        local info = debug.info(v, "s")
        if consts[1] == "ProjectileSpeed" and string.match(info, "RangedWeaponClient") then
            createProjectile = v
        elseif debug.info(v, "n") == "updatePlayers" and string.match(info, "PlayerClient") then
            players_data = debug.getupvalue(v, 1)
        end
    end
end

-- Prediction Math
function CalculateBulletDrop(tPos, tVel, cPos, pSpeed, pDrop)
    local dTT = (tPos - cPos).Magnitude
    local tTT = dTT / pSpeed
    local adjustedVel = Vector3.new(tVel.X, 0, tVel.Z) * 7 + Vector3.new(0, tVel.Y, 0) * 2
    local pTP = tPos + (adjustedVel * tTT)
    local dP = -pDrop ^ (tTT * pDrop) + 1
    return pTP - Vector3.new(0, dP, 0)
end

-- Silent Aim Hook
local validGuns = {"AR15", "C9", "Crossbow", "Bow", "EnergyRifle", "GaussRifle", "HMAR", "KABAR", "M4A1", "PipePistol", "SCAR", "SVD", "USP9", "UZI"}
local oldCreateProjectile; oldCreateProjectile = hookfunction(createProjectile, function(cFrame, weaponInfo, isLocal, p63, p64)
    if isLocal and settings.silentAim.Enabled then
        local target, index = nil, 0
        local closestDist = settings.silentAim.Fov.BaseRadius
        for idx, p in pairs(players_data) do
            if p.model and p.model:FindFirstChild(settings.silentAim.HitPart) then
                local pos, vis = Camera:WorldToViewportPoint(p.model[settings.silentAim.HitPart].Position)
                local dist2D = (Vector2.new(pos.X, pos.Y) - (Camera.ViewportSize / 2)).Magnitude
                if vis and dist2D < closestDist then
                    closestDist = dist2D
                    target = p.model[settings.silentAim.HitPart]
                    index = idx
                end
            end
        end
        if target and table.find(validGuns, tostring(weaponInfo.type)) then
            local pVel = Vector3.zero
            for i, p in pairs(players_data) do if i == index then pVel = p.velocityVector or Vector3.zero break end end
            local prediction = CalculateBulletDrop(target.Position, pVel, cFrame.Position, weaponInfo.ProjectileSpeed, weaponInfo.ProjectileDrop or 0)
            cFrame = CFrame.new(cFrame.Position, prediction)
        end
    end
    return oldCreateProjectile(cFrame, weaponInfo, isLocal, p63, p64)
end)

-- // 3. ESP HELPERS //
local SkeletonBones = {
    {"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"},
    {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"},
    {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"},
    {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}
}

local function IsSleeping(model)
    local anims = model:FindFirstChild("AnimationController")
    if not anims then return false end
    for _, v in pairs(anims:GetPlayingAnimationTracks()) do
        if v.Animation.AnimationId == "rbxassetid://13280887764" and v.IsPlaying then return true end
    end
    return false
end

-- // 4. UI TABS //
local combatTab = DrRayLibrary.newTab("Combat", "rbxassetid://4483345998")
local espTab = DrRayLibrary.newTab("ESP", "rbxassetid://4483345998")
local miscTab = DrRayLibrary.newTab("Misc", "rbxassetid://4483345998")

-- Combat
combatTab.newToggle("Silent Aim", "Enable Aim", false, function(s) settings.silentAim.Enabled = s end)
combatTab.newToggle("Show FOV", "Circle", false, function(s) settings.silentAim.Fov.Visible = s end)
combatTab.newSlider("FOV Radius", "Size", 500, false, function(s) settings.silentAim.Fov.BaseRadius = s end)
combatTab.newDropdown("Hitbox Part", "Target", {"Head", "Torso"}, function(s) settings.combat.HitPart = s end)
combatTab.newSlider("Hitbox Size", "Expansion", 20, true, function(s) settings.combat.HitboxSize = s end)

-- ESP
espTab.newToggle("Master", "Enable", true, function(s) settings.esp.Enabled = s end)
espTab.newToggle("Box", "Boxes", true, function(s) settings.esp.Box = s end)
espTab.newToggle("Skeleton", "Skeletons", true, function(s) settings.esp.Skeleton = s end)
espTab.newToggle("Weapon", "Held Item", true, function(s) settings.esp.Weapon = s end)
espTab.newToggle("Armor", "Armor Tier", true, function(s) settings.esp.Armor = s end)
espTab.newToggle("Corpse ESP", "Show Dead", true, function(s) settings.esp.ShowCorpses = s end)

-- Misc
miscTab.newToggle("free cam", "rightdpad to activate", false, function(s) settings.misc.FreecamEnabled = s end)
miscTab.newButton("Jump Shoot", "Enable", function() hookfunction(getrenv()._G.classes.Character.IsGrounded, function() return true end) end)

-- // 5. ESP LOGIC & FREECAM //
local CustomDrawing = loadstring(game:HttpGet("https://raw.githubusercontent.com/Pumpuma/UKI/main/Mycustomdrawing.lua"))()
local screenGui = Instance.new("ScreenGui", CoreGui); screenGui.IgnoreGuiInset = true

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness, fovCircle.Filled = 1, false

local cam_pos, cam_rot = Camera.CFrame.Position, Vector2.new(0, 0)
UIS.InputBegan:Connect(function(i, p)
    if not p and i.KeyCode == Enum.KeyCode.DPadRight then
        settings.misc.FreecamEnabled = not settings.misc.FreecamEnabled
        Camera.CameraType = settings.misc.FreecamEnabled and Enum.CameraType.Scriptable or Enum.CameraType.Custom
        if LocalPlayer.Character then LocalPlayer.Character.HumanoidRootPart.Anchored = settings.misc.FreecamEnabled end
        cam_pos = Camera.CFrame.Position
    end
end)

RunService.RenderStepped:Connect(function()
    screenGui:ClearAllChildren()
    local rainbow = Color3.fromHSV((tick() * 0.5) % 1, 0.8, 1)
    
    -- Visuals
    fovCircle.Visible = settings.silentAim.Fov.Visible and settings.silentAim.Enabled
    fovCircle.Radius = settings.silentAim.Fov.BaseRadius
    fovCircle.Position = Camera.ViewportSize / 2
    
    if settings.esp.Enabled then
        for _, model in pairs(Workspace:GetChildren()) do
            -- Corpse ESP
            if settings.esp.ShowCorpses and model:FindFirstChildOfClass("UnionOperation") and model:FindFirstChildOfClass("UnionOperation").Color == Color3.fromRGB(205, 205, 205) then
                local cf = model:GetBoundingBox()
                local pos, vis = Camera:WorldToViewportPoint(cf.Position)
                if vis then CustomDrawing.new("Text").create(screenGui, Vector2.new(pos.X, pos.Y), "Corpse", Color3.new(1,1,1)) end
            end

            -- Player ESP
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and model ~= LocalPlayer.Character then
                local root = model.HumanoidRootPart
                local pos, vis = Camera:WorldToViewportPoint(root.Position)
                if vis then
                    if settings.esp.SleepCheck and IsSleeping(model) then continue end
                    
                    local dist = math.ceil((Camera.CFrame.Position - root.Position).Magnitude/3.2)
                    if settings.esp.Box then CustomDrawing.new("Square").create(screenGui, Vector2.new(pos.X, pos.Y), 40, 60, rainbow, rainbow, 1) end
                    if settings.esp.Name then CustomDrawing.new("Text").create(screenGui, Vector2.new(pos.X, pos.Y - 40), model.Name, rainbow) end
                    if settings.esp.Weapon then CustomDrawing.new("Text").create(screenGui, Vector2.new(pos.X, pos.Y + 35), model:GetAttribute("RealName") or "None", rainbow) end
                    if settings.esp.Distance then CustomDrawing.new("Text").create(screenGui, Vector2.new(pos.X, pos.Y + 50), dist.."m", rainbow) end
                    
                    if settings.esp.Skeleton then
                        for _, bone in pairs(SkeletonBones) do
                            local b1, b2 = model:FindFirstChild(bone[1]), model:FindFirstChild(bone[2])
                            if b1 and b2 then
                                local p1 = Camera:WorldToViewportPoint(b1.Position)
                                local p2 = Camera:WorldToViewportPoint(b2.Position)
                                CustomDrawing.new("Line").create(screenGui, Vector2.new(p1.X, p1.Y), Vector2.new(p2.X, p2.Y), rainbow, 1)
                            end
                        end
                    end

                    -- Hitbox Logic
                    if settings.combat.HitboxEnabled then
                        local hb = model:FindFirstChild(settings.combat.HitPart)
                        if hb then hb.Size = Vector3.new(settings.combat.HitboxSize, settings.combat.HitboxSize, settings.combat.HitboxSize); hb.Transparency = 0.6 end
                    end
                end
            end
        end
    end
end)
local camera = workspace.CurrentCamera
local runService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local players = {}
local createProjectile

local silentAim = {
    Enabled = true,
    HitPart = "Head",
    MaxDistance = 2500,
    TargetSleeping = true,
    TargetScientists = false,
    Fov = {
        BaseRadius = 200,
        Visible = true,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1,
        Transparency = 1,
        Filled = false
    },
    Snapline = {
        Enabled = true,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1,
        Transparency = 1
    },
    Highlight = {
        Enabled = true,
        Color = Color3.fromRGB(255, 255, 255),
        FillTransparency = 1
    }
}

local validGuns = {
    "AR15", "C9", "Crossbow", "Bow", "EnergyRifle", "GaussRifle",
    "HMAR", "KABAR", "LeverActionRifle", "M4A1", "PipePistol",
    "PipeSMG", "PumpShotgun", "SCAR", "SVD", "USP9", "UZI", "Blunderbuss"
}

local function IsValidGun(gun)
    return table.find(validGuns, tostring(gun)) ~= nil
end

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = silentAim.Fov.Thickness
fovCircle.NumSides = 64
fovCircle.Filled = silentAim.Fov.Filled
fovCircle.ZIndex = 999

local snapLine = Drawing.new("Line")
snapLine.ZIndex = 998

local HL = Instance.new("Highlight")
HL.Name = "SilentAimHighlight"
HL.Parent = CoreGui
HL.FillTransparency = silentAim.Highlight.FillTransparency

for i, v in getgc() do
    if typeof(v) == "function" and not iscclosure(v) then
        local consts = debug.getconstants(v)
        local info = debug.info(v, "s")
        if consts[1] == "ProjectileSpeed" and string.match(info, "RangedWeaponClient") then
            createProjectile = v
        elseif debug.info(v, "n") == "updatePlayers" and string.match(info, "PlayerClient") then
            players = debug.getupvalue(v, 1)
        end
    end
end

local function isPlayerVisible(hitPart)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {camera.Parent or camera}
    raycastParams.IgnoreWater = true
    local origin = camera.CFrame.Position
    local direction = (hitPart.Position - origin)
    local rayResult = workspace:Raycast(origin, direction, raycastParams)
    if rayResult then
        local hitModel = rayResult.Instance:FindFirstAncestorOfClass("Model")
        if hitModel and hitModel == hitPart.Parent then
            return true
        end
        return false
    end
    return true
end

local function getClosestPlayer()
    local closest = nil
    local closestIndex = 0
    local closestDist = math.huge
    local center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    for idx, player in pairs(players) do
        if not player.model then
            continue
        end
        
        if player.sleeping and not silentAim.TargetSleeping then
            continue
        end
        
        if player.type == "Scientist" and not silentAim.TargetScientists then
            continue
        end
        
        local head = player.model:FindFirstChild("Head")
        if not head then
            continue
        end
        local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
        if not onScreen or screenPos.Z <= 0 then
            continue
        end
        local dist2D = (center - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if dist2D > fovCircle.Radius then
            continue
        end
        local dist3D = (head.Position - camera.CFrame.Position).Magnitude
        if dist3D > silentAim.MaxDistance then
            continue
        end
        if not isPlayerVisible(head) then
            continue
        end
        if dist2D < closestDist then
            closestDist = dist2D
            closest = head
            closestIndex = idx
        end
    end
    return closest, closestIndex
end

function CalculateBulletDrop(tPos, tVel, cPos, pSpeed, pDrop)
    local dTT = (tPos - cPos).Magnitude
    local tTT = dTT / pSpeed

    local sVE = 8.8 - (pSpeed / (400 + pSpeed / 30))

    local horizontalVel = Vector3.new(tVel.X, 0, tVel.Z) * 7
    local verticalVel = Vector3.new(0, tVel.Y, 0) * 2

    local adjustedVel = horizontalVel + verticalVel

    local pTP = tPos + (adjustedVel * tTT)

    local dP = -pDrop ^ (tTT * pDrop) + 1
    local pPWD = pTP - Vector3.new(0, dP, 0)

    return pPWD
end

local oldCreateProjectile
oldCreateProjectile = hookfunction(createProjectile, function(cFrame, weaponInfo, isLocal, p63, p64)
    if isLocal and silentAim.Enabled then
        local hitPart, index = getClosestPlayer()
        if hitPart and IsValidGun(weaponInfo.type) then
            local playerVelocity = Vector3.zero
            for i, player in pairs(players) do
                if i == index and player.velocityVector then
                    playerVelocity = player.velocityVector
                    break
                end
            end
            local prediction = CalculateBulletDrop(
                hitPart.Position,
                playerVelocity,
                cFrame.Position,
                weaponInfo.ProjectileSpeed,
                weaponInfo.ProjectileDrop or 0
            )
            cFrame = CFrame.new(cFrame.Position, prediction)
        end
    end
    return oldCreateProjectile(cFrame, weaponInfo, isLocal, p63, p64)
end)

runService.RenderStepped:Connect(function()
    local center = camera.ViewportSize / 2
    local baseRadius = silentAim.Fov.BaseRadius
    local fovScale = baseRadius * (math.tan(math.rad(50)) / math.tan(math.rad(camera.FieldOfView))) ^ 0.35
    
    if silentAim.Fov.Visible and silentAim.Enabled then
        fovCircle.Visible = true
        fovCircle.Position = center
        fovCircle.Radius = fovScale
        fovCircle.Color = silentAim.Fov.Color
        fovCircle.Thickness = silentAim.Fov.Thickness
        fovCircle.Transparency = silentAim.Fov.Transparency
        fovCircle.Filled = silentAim.Fov.Filled
    else
        fovCircle.Visible = false
    end

    local targetHead = getClosestPlayer()
    if targetHead then
        local screenPos, onScreen = camera:WorldToViewportPoint(targetHead.Position)
        local screenVec = Vector2.new(screenPos.X, screenPos.Y)
        
        if silentAim.Snapline.Enabled and onScreen then
            snapLine.Visible = true
            snapLine.From = center
            snapLine.To = screenVec
            snapLine.Color = silentAim.Snapline.Color
            snapLine.Thickness = silentAim.Snapline.Thickness
            snapLine.Transparency = silentAim.Snapline.Transparency
        else
            snapLine.Visible = false
        end
        
        if silentAim.Highlight.Enabled then
            HL.Adornee = targetHead.Parent
            HL.OutlineColor = silentAim.Highlight.Color
            HL.FillTransparency = silentAim.Highlight.FillTransparency
        else
            HL.Adornee = nil
        end
    else
        snapLine.Visible = false
        HL.Adornee = nil
    end
end)